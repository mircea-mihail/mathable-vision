import cv2 as cv

from image_processing import *
from constants import *

# generates the solution files for all the photos in the input dir
def generate_solution():
    files = os.listdir(INPUT_DIR)

    photos = sorted([file for file in files if os.path.splitext(file)[1] == ".jpg"])
    turns_files = sorted([file for file in files if file.split("_")[1] == "turns.txt"])


    data_set = -1
    templates = load_templates()
    moves_results = []

    for photo in photos: 
        current_set = int(photo.split('_')[0])

        # switch game
        if current_set != data_set:
            if data_set != -1:
                print("\nscores:\n", moves_results, "\n\n", sep="")
                moves_results.append(move_score)
                write_results(turns_file, data_set, moves_results)

            #start fresh
            prev_board = get_board(EMPTY_BOARD_PATH)
            move_matrix = init_move_matrix()
            data_set = current_set

            turns_file = [file for file in turns_files if int(file.split("_")[0]) == data_set][0]
            print(turns_file)
            print("moves:")
            players_moves = get_players_moves(turns_file)
            players_moves.append(1000)

            moves_results = []
            current_move = 0
            current_turn_idx = 0
            move_score = 0

        # switch player
        if current_move >= players_moves[current_turn_idx + 1]:
            print()
            moves_results.append(move_score)
            current_turn_idx += 1
            move_score = 0

        board = get_board(photo)
        move_pos = get_board_change(prev_board, board)

        res_string = str(BOARD_Y_VALS[move_pos[Y]]) + str(BOARD_X_VALS[move_pos[X]])
        move_val = get_similitude(process_square(get_square(process_board(board), move_pos[X], move_pos[Y])), templates)
        res_string = res_string + " " + str(move_val)

        # write step
        with open(os.path.join(OUTPUT_DIR, os.path.splitext(photo)[0] + ".txt"), 'w') as file:
            file.write(res_string)

        move_matrix[move_pos[Y], move_pos[X]] = move_val
        move_score += get_score(move_pos[X], move_pos[Y], move_val, move_matrix)
        prev_board = board
        current_move += 1 

        print(move_score, ", ", end=" ")

    moves_results.append(move_score)
    print("\nscores:\n", moves_results, "\n\n", sep="")
    write_results(turns_file, data_set, moves_results)

def get_board_change(prev_board, cur_board):
    diff_board = cv.absdiff(prev_board, cur_board)

    changed_square = [0, 0] 
    best_score = 0
    for i in range(TOTAL_SQUARES):
        for j in range(TOTAL_SQUARES):
            cur_score = np.sum(get_square(diff_board, j, i))
            if cur_score > best_score:
                best_score = cur_score
                changed_square[X] = j
                changed_square[Y] = i
    return changed_square

# returns the adnotations written in the _turns file, when each player's move starts, offset by one to start from 0
def get_players_moves(turns_file):
    players_moves = []

    with open(os.path.join(INPUT_DIR, turns_file), "r") as file:
        for line in file.readlines():
            players_moves.append(int(line.split(" ")[1].replace("\n", "")) - 1)

    return players_moves

# initialises the move matrix with minus ones and places 1 2 3 4 in the middle
def init_move_matrix():
    mat = np.full((14, 14), -1)
    mat[6][6] = 1
    mat[6][7] = 2
    mat[7][6] = 3
    mat[7][7] = 4

    return mat

# checks every ecuation between a and b and returns true if any matches the result using the constraint 
def check_ecuations(a, b, res, constraint):
    if constraint == NC:
        if a + b == res or abs(a - b) == res or a * b == res:
            return True
        if a != 0 and b != 0 and max(a, b) / min(a, b) == res:
            return True

    if constraint == PL and a + b == res:
        return True
    if constraint == MI and abs(a - b) == res:
        return True
    if constraint == MU and a * b == res:
        return True
    if constraint == DV: 
        if a != 0 and b != 0 and max(a, b) / min(a, b) == res:
            return True
    
    return False

# returns the score generated by placing a piece on the board at x and y locations
def get_score(x, y, val, board_mat):
    ecuations_found = 0
    # sus:
    if y > 1:
        a = board_mat[y - 1][x] 
        b = board_mat[y - 2][x]
        if a != -1 and b != -1:
            if check_ecuations(a, b, val, CONSTRAINTS[y][x]):
                ecuations_found += 1
    if y < 12:
        a = board_mat[y + 1][x] 
        b = board_mat[y + 2][x]
        if a != -1 and b != -1: 
            if check_ecuations(a, b, val, CONSTRAINTS[y][x]):
                ecuations_found += 1
    if x > 1:
        a = board_mat[y][x - 1] 
        b = board_mat[y][x - 2]
        if a != -1 and b != -1:
            if check_ecuations(a, b, val, CONSTRAINTS[y][x]):
                ecuations_found += 1
    if x < 12:
        a = board_mat[y][x + 1] 
        b = board_mat[y][x + 2]
        if a != -1 and b != -1:
            if check_ecuations(a, b, val, CONSTRAINTS[y][x]):
                ecuations_found += 1

    return val * ecuations_found * BONUSES[y][x]

# writes the results of the moves to the _scores output file
def write_results(turns_file, data_set, moves_results):
    with open(os.path.join(INPUT_DIR, turns_file), "r") as inspiration_file:
        lines = inspiration_file.readlines()
        with open(os.path.join(OUTPUT_DIR, str(data_set) + "_turns.txt"), "w") as file:
            file.writelines(lines)

        with open(os.path.join(OUTPUT_DIR, str(data_set) + "_scores.txt"), "w") as file:
            for i in range(len(lines)):
                lines[i] = lines[i].replace("\n", "") + " " + str(moves_results[i]) + "\n"
            file.writelines(lines)